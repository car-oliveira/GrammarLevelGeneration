using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using UnityEngine.SceneManagement;

public class Generator : MonoBehaviour
{
    [SerializeField] private LayerMask _collisionLayer;


    //List of the room types with the associated assets
    public List<RoomAsset> roomAssets;

    //List of the room types with the associated content assets
    public List<ContentAsset> contentAssets;

    //Asset for the room that is instantiated when the pieces from the sentence don't fit
    public GameObject endPiece;

    //Scriptable object that manages all the functions related to grammars
    public GrammarManager grammarManager;

    //Number of attempts before the generator returns error
    public int numberOfAttempts;

    //The minimum length for a sentence to be generated by the grammar
    public int minimumSentenceSize;

    //Value by which a rule that is applied is decreased and the rules with the least probability is increased
    public int probabilityAdjustment;

    public int minimumProbability;

    public int maximumProbability;

    public int maximumContentPerRoom;

    //Text file containing the level grammar
    public TextAsset levelGrammarFile;

    //Text file containint the content grammar
    public TextAsset contentGrammarFile;

    //Current string being parsed for level generation
    string levelString;

    //Queue of the asset to be instantiated from the current sentence
    List<string> assetQueue;

    //RESULTS SECTION
    //Composition of all the level
    public string renderedLevel=string.Empty;

    string renderedContent=string.Empty;

    int attemptsUsed=1;

    float timePassed;

    //List of the insantiated object from the current string
    List<GameObject> currentString;

    //List of all the room game objects present in the current string
    List<GameObject> roomsInCurrent;

    //List of all the rooms in the level
    List<GameObject> roomsInLevel;

    //current position of the current string list
    private int currentListIndex = 0;

    //current position of the current level list
    private int levelListIndex = 0;

    //list of rooms that still have an open main exit
    List<GameObject> roomsToExpand;

    //current index of the rooms to expand list
    int roomsIndex = 0;

    //current level generation attempt
    int currentAttempt=0;

    //true if current piece being generated is the end piece
    bool isEndPiece = false;

    //level container
    GameObject level;

    GameObject roomToExpand;

    List<Vector3> occupiedContent = new List<Vector3>();

     public GameObject previousRoom;

    // Start is called before the first frame update
    void Start()
    {
        //this.roomsInCurrent = new List<GameObject>();
        //this.roomsToExpand = new List<GameObject>();
        //this.roomsInLevel = new List<GameObject>();
        //this.grammarManager.ResetCopyGrammars();
        //CheckForSeedFile();
        //GrammarManager grammarManager = this.GetComponent<GrammarManager>();
        //string test = grammarManager.contentGrammar.grammar.GenerateSentenceFromString("Corridor");
        //this.levelString = grammarManager.levelGrammar.grammar.GenerateSentence();
        //this.grammarManager.ResetCopyGrammars();
        //levelString = grammarManager.GenerateLevelSentence();
        //this.levelString = "Start LCorridor LCorridor LCorridor Corridor Corridor Corridor End";
        //this.levelString = "Start 4Way End";
        PlayerPrefs.GetInt("Attempt", 1);
        PlayerPrefs.Save();
        GenerateLevel();
    }

    //Gets the asset for the end piece
    public bool GetIsEndPiece()
    {
        return this.isEndPiece;
    }

    //Chekcs if there is a seed file in the project folder
    public void CheckForSeedFile()
    {
        string fileDestination = Application.dataPath + "/seed.dat";
        if (File.Exists(fileDestination))
        {
            ImportSeedFromFile();
        }
        else
        {
            ExportSeedToFile();
        }
    }


    //Exports the current seed to a file
    public void ExportSeedToFile()
    {
        UnityEngine.Random.State seed = UnityEngine.Random.state;
        string fileDestination = Application.dataPath + "/seed.dat";
        FileStream file=File.Create(fileDestination);
        BinaryFormatter binaryFormatter = new BinaryFormatter();
        binaryFormatter.Serialize(file, seed);
        file.Close();
    }

    //Imports the seed from a file
    public void ImportSeedFromFile()
    {
        string fileDestination = Application.dataPath + "/seed.dat";
        FileStream file = File.OpenRead(fileDestination);
        BinaryFormatter binaryFormatter = new BinaryFormatter();
        UnityEngine.Random.State seed = (UnityEngine.Random.State) binaryFormatter.Deserialize(file);
        UnityEngine.Random.state = seed;
    }

    //Checks if the sentence's length is at least the minimum defined in the editor
    public bool CheckSentenceSize(string sentence)
    {
        bool sentenceSizeEval = false;
        string[] splitLevelString = levelString.Split(' ');
        if (splitLevelString.Length >= this.minimumSentenceSize)
        {
            sentenceSizeEval = true;
        }
        return sentenceSizeEval;
    }

    //Generates a new string without the starting symbol. Used the create string to expand open exits
    public void DefineNextString()
    {
        string newString = grammarManager.levelGrammar.grammar.GenerateSentence();
        List<string> newStringList = newString.Split(' ').ToList();
        newStringList.RemoveAt(0);
        //this.levelString = newStringList.ToString();
        foreach (string split in newStringList)
        {
            this.assetQueue.Add(split);
        }
        this.levelString = String.Join(" ", newStringList.ToArray());
        //GenerateQueueFromString(this.levelString);
    }

    public void DefineNewStartingExit()
    {
        GameObject level = GameObject.Find("Level");
        Transform exit = level.transform.Find("Exit");
    }

    //Checks if there are still any exits without a patch
    public bool HasMainExits()
    {
        GameObject levelObject = GameObject.Find("Level");
        foreach(Transform room in levelObject.transform)
        {
            Room roomScript = room.gameObject.GetComponent<Room>();
            if (roomScript.GetRoomMainExit(room.gameObject) != null)
            {
                return true;
            }
        }
        return false;
    }

    public int GetNextRoomToExpand()
    {
        int roomIndex;
        for (roomIndex = 0; roomIndex < this.roomsInLevel.Count(); roomIndex++)
        {
            if (CheckHasExit(this.roomsInLevel.ElementAt(roomIndex)))
            {
                this.roomToExpand=this.roomsInLevel.ElementAt(roomIndex);
                return roomIndex;
            }
        }
        return -1;
    }

    public bool CheckHasExit(GameObject room)
    {
        foreach (Transform child in room.transform)
        {
            if (child.tag == "Exit")
            {
                return true;
            }
        }
        return false;
    }

    public void SwitchMainExitToConnected(GameObject room)
    {
        foreach (Transform child in room.transform)
        {
            if (child.tag == "Main_Exit")
            {
                child.tag = "Connected_Exit";
            }
        }
    }

    public void writeResultsToFile()
    {
        string path = (Application.dataPath + "/results.txt");
            StreamWriter writer = new StreamWriter(path, true);
        writer.WriteLine("Level: " + this.renderedLevel);
        writer.WriteLine("Content: " + this.renderedContent);
        //writer.WriteLine("Attempts: " + this.attemptsUsed);
        writer.WriteLine("Time: " + this.timePassed);
        writer.WriteLine("");
        writer.Close();
        //File.WriteAllText(Application.dataPath + "/results.txt","Level: " + this.renderedLevel + "\n");
    }

    public void writeErrorToFile()
    {
        string path = (Application.dataPath + "/results.txt");
        StreamWriter writer = new StreamWriter(path, true);
        writer.WriteLine("Number of attempts exceeded");
        writer.Close();
    }

    public void writeAttemptsToFile()
    {
        string path = (Application.dataPath + "/attempt.txt");
        StreamWriter writer = new StreamWriter(path, true);
        writer.WriteLine(this.attemptsUsed);
        writer.Close();
    }

    //public void readAttemptFromFile()
    //{
    //    string path = (Application.dataPath + "/attempt.txt");
    //    StreamReader reader = new StreamReader(path, true);
    //    string line = reader.ReadLines().Last();
    //    this.attemptsUsed = int.Parse(line);
    //    reader.Close();
    //}

    public void SwitchExitToMain(GameObject room)
    {
        foreach (Transform child in room.transform)
        {
            if (child.tag == "Exit")
            {
                child.tag = "Main_Exit";
            }
            return;
        }
    }

    public void ExpandNextPath()
    {
        GameObject mainExit = GameObject.FindGameObjectWithTag("Main_Exit");
        if (mainExit != null)
        {
            Transform entry = mainExit.transform.parent;
            GameObject nextRoom = entry.parent.gameObject;
            //nextRoom.GetComponent<Room>().SwitchExits();
            DefineNextString();
            roomsInCurrent = new List<GameObject>();
            //roomsInCurrent.Add(nextRoom);
            GameObject levelObject=GameObject.Find("Level");
            GameObject room;
            string assetName = GetNextAssetInQueue();
            GameObject roomAsset = GetRoomAssetFromName(assetName);
            room = Instantiate(roomAsset, nextRoom.transform.position, Quaternion.identity, levelObject.transform);
            room.tag = "New Room";
            room.GetComponent<Room>().setRoomType(assetName);
            room.GetComponent<Room>().SetPreviousRoom(nextRoom);
        }
        else
        {
            //readAttemptFromFile();
            //this.timePassed = Time.realtimeSinceStartup;
            //writeResultsToFile();
            PopulateRooms();
        }
    }

    //Starts the level generation given a string containing the rooms that compose it
    public void GenerateLevel()
    {
        //CheckForSeedFile();
        this.roomsInCurrent = new List<GameObject>();
        this.roomsToExpand = new List<GameObject>();
        this.roomsInLevel = new List<GameObject>();
        this.grammarManager.ResetCopyGrammars();
        currentListIndex = 0;
        //this.levelString = "Start 4Way End";
        this.levelString = grammarManager.GenerateLevelSentence();
        bool sentenceCheck = CheckSentenceSize(this.levelString);
        while (sentenceCheck == false)
        {
            this.levelString = grammarManager.GenerateLevelSentence();
            sentenceCheck = CheckSentenceSize(this.levelString);
        }
        Debug.Log(this.levelString);
        GenerateQueueFromString(this.levelString);
        Vector3 position = new Vector3(0, 0, 0);
        this.level = new GameObject("Level");
        InstantiateFirstRoom(position, level);
    }

    public void RestartLevel()
    {
        foreach (Transform room in this.level.transform)
        {
            Destroy(room.gameObject);
        }
        Destroy(this.level);
        GenerateLevel();
    }

    //Goes through each room and generates content using grammar and populates the room with it
    public void PopulateRooms()
    {
        GameObject levelObject = GameObject.Find("Level");
        GameObject[] containerArray=GetAllRoomColliderContainers();
        //DisableColliderContainerArray(containerArray);
        foreach (Transform room in levelObject.transform)
        {
            Room roomScript = room.gameObject.GetComponent<Room>();
            string roomType = roomScript.GetRoomType();
            string contentString = grammarManager.contentGrammar.grammar.GenerateSentenceFromString(roomType);
            Queue<string> contentQueue = new Queue<string>();
            string[] splitContentString = contentString.Split(' ');
            foreach (string split in splitContentString)
            {
                contentQueue.Enqueue(split);
            }
            //while(contentQueue.Count > maximumContentPerRoom)
            //{
            //    contentString = grammarManager.contentGrammar.grammar.GenerateSentenceFromString(roomType);
            //    contentQueue = new Queue<string>();
            //    splitContentString = contentString.Split(' ');
            //    foreach (string split in splitContentString)
            //    {
            //        contentQueue.Enqueue(split);
            //    }
            //}

                InstantiateRoomContent(contentQueue, roomScript.GetColliderContainer(room.gameObject).GetComponent<BoxCollider>(), room);
        }
        this.timePassed = Time.realtimeSinceStartup;
        writeResultsToFile();
    }



    //Turns the string generated from a grammar into a queue to be used in the generation process
    public void GenerateQueueFromString(string levelString)
    {
        this.assetQueue = new List<string>();
        string[] splitLevelString = levelString.Split(' ');
        foreach(string split in splitLevelString)
        {
            this.assetQueue.Add(split);
        }
    }

    //Obtains the next asset to generate from the next string in the queue
    public string GetNextAssetInQueue()
    {
        if (currentListIndex < this.assetQueue.Count())
        {
            string nextAsset = this.assetQueue.ElementAt(currentListIndex);
            currentListIndex++;
            return nextAsset;
        }
        return null;

    }

    public bool QueueHasMoreAsset()
    {
        if (currentListIndex < this.assetQueue.Count())
        {
            return true;
        }
        return false;
    }


    //Instantiates the starting room in the level
    public GameObject InstantiateFirstRoom(Vector3 position, GameObject level)
    {
        string assetName = GetNextAssetInQueue();
        GameObject roomAsset = GetRoomAssetFromName(assetName);
        GameObject firstRoom = Instantiate(roomAsset, position, Quaternion.identity, level.transform);
        firstRoom.tag = "Previous Room";
        firstRoom.GetComponent<Room>().setRoomType(assetName);
        this.roomsInCurrent.Add(firstRoom);
        return firstRoom;
    }

    public GameObject InstantiateNextRoom(GameObject level, GameObject previousRoom)
    {
        GameObject room;
        string assetName = GetNextAssetInQueue();
        GameObject roomAsset = GetRoomAssetFromName(assetName);
        room = Instantiate(roomAsset, previousRoom.transform.position, Quaternion.identity, level.transform);
        room.tag = "New Room";
        room.GetComponent<Room>().setRoomType(assetName);
        room.GetComponent<Room>().SetPreviousRoom(previousRoom);

        //if (this.currentListIndex<this.assetQueue.Count())
        //{
        //    string assetName = GetNextAssetInQueue();
        //    GameObject previousRoom = this.roomsInCurrent.ElementAt(this.roomsInCurrent.Count - 1);
        //    GameObject roomAsset = GetRoomAssetFromName(assetName);
        //    room = Instantiate(roomAsset, previousRoom.transform.position, Quaternion.identity, level.transform);
        //    room.tag = "New Room";
        //    room.GetComponent<Room>().setRoomType(assetName);
        //    room.GetComponent<Room>().SetPreviousRoom(previousRoom);
        //}
        //else
        //{
        //    GameObject previousRoom = null;
        //    if (this.roomsInCurrent.Count>1)
        //    {
        //        previousRoom = this.roomsInCurrent.ElementAt(this.roomsInCurrent.Count - 1);

        //    }
        //    else{
        //        previousRoom = this.roomToExpand;

        //    }

        //    GameObject roomAsset = GetEndPiece();
        //    isEndPiece = true;
        //    room = Instantiate(roomAsset, previousRoom.transform.position, Quaternion.identity, level.transform);
        //    room.tag = "New Room";
        //    room.GetComponent<Room>().setRoomType("End");
        //    room.GetComponent<Room>().SetPreviousRoom(previousRoom);
        //}
        this.roomsInCurrent.Add(room);
        return room;
    }

    public GameObject InstatiateEndPiece(GameObject level, GameObject previousRoom)
    {
        GameObject room;
        //GameObject previousRoom = this.roomsInCurrent.ElementAt(this.roomsInCurrent.Count - 1);
        GameObject roomAsset = GetEndPiece();
        this.isEndPiece = true;
        room = Instantiate(roomAsset, previousRoom.transform.position, Quaternion.identity, level.transform);
        room.tag = "New Room";
        room.GetComponent<Room>().setRoomType("End");
        room.GetComponent<Room>().SetPreviousRoom(previousRoom);
        this.roomsInCurrent.Add(room);
        return room;
    }

    public bool CheckContentCollision(Vector3 position) {
        if (this.occupiedContent.Contains(position))
        {
            return true;
        }
        return false;
    }

    Vector3 AbsoluteValue(Vector3 absoluteVector)
    {
        return new Vector3(Mathf.Abs(absoluteVector.x), Mathf.Abs(absoluteVector.y), Mathf.Abs(absoluteVector.z));
    }

    //Spawns the content of a room
    public void InstantiateRoomContent(Queue<string> contentString, BoxCollider boxCollider, Transform room)
    {
        string nextContent;
        while (contentString.Count > 0)
        {
            nextContent = contentString.Dequeue();
            GameObject asset = GetContentAssetFromName(nextContent);
            if (asset != null)
            {
                Vector3 roomCenter = boxCollider.center;
                Vector3 limits = (boxCollider.bounds.size) / 2;
                Vector3 worldCenter = boxCollider.transform.TransformPoint(boxCollider.center);
                Vector3 worldHalfExtents = boxCollider.transform.TransformVector(boxCollider.size * 0.5f);
                float posX = UnityEngine.Random.Range((-worldHalfExtents.x), worldHalfExtents.x);
                float posY = (worldHalfExtents.y)/2;
                //float posY = UnityEngine.Random.Range((-worldHalfExtents.y), worldHalfExtents.y);
                float posZ = UnityEngine.Random.Range((-worldHalfExtents.z), worldHalfExtents.z);
                Vector3 position = roomCenter + new Vector3(posX, worldHalfExtents.y, posZ);
                bool collision = CheckContentCollision(position);
                Vector3 rayPos = worldCenter + new Vector3(posX, roomCenter.y, posZ);
                Vector3 rayDirection = -Vector3.up;
                RaycastHit hit;
                float rayDistance = 10f;
                Debug.DrawRay(rayPos, rayDirection * rayDistance, Color.red);
                bool placeContent = false;
                Physics.Raycast(rayPos, rayDirection, out hit, rayDistance, _collisionLayer);
                
                    //Debug.Log("Raycast hit: " + hit.transform.gameObject.layer);

                while (placeContent == false)
                {
                    if (Physics.Raycast(rayPos, rayDirection, out hit, rayDistance, _collisionLayer))
                    {
                        if (hit.transform.gameObject.layer != 9)
                        {
                            posX = UnityEngine.Random.Range((-worldHalfExtents.x), worldHalfExtents.x);
                            posZ = UnityEngine.Random.Range((-worldHalfExtents.z), worldHalfExtents.z);
                            rayPos = worldCenter + new Vector3(posX, posY, posZ);
                        }
                        else
                        {
                            GameObject content = Instantiate(asset, rayPos, Quaternion.identity, room);
                            this.renderedContent += nextContent + " ";
                            placeContent = true;
                        }
                    }
                    else
                    {
                        posX = UnityEngine.Random.Range((-worldHalfExtents.x), worldHalfExtents.x);
                        posZ = UnityEngine.Random.Range((-worldHalfExtents.z), worldHalfExtents.z);
                        rayPos = worldCenter + new Vector3(posX, posY, posZ);
                    }
                }


                //while (collision)
                //{
                //    posX = UnityEngine.Random.Range((-worldHalfExtents.x), worldHalfExtents.x);
                //    posY = UnityEngine.Random.Range((-worldHalfExtents.y), worldHalfExtents.y);
                //    posZ = UnityEngine.Random.Range((-worldHalfExtents.z), worldHalfExtents.z);
                //    position = worldCenter + new Vector3(posX, worldHalfExtents.y, posZ);
                //}
                //this.occupiedContent.Add(position);
                //GameObject content = Instantiate(asset, position, Quaternion.identity);
                //this.renderedContent += nextContent + " ";
            }

        }
    }

    //Gets all of the rooms colliders
    public GameObject[] GetAllRoomColliderContainers()
    {
        return GameObject.FindGameObjectsWithTag("Container");
    }

    //Disables all of the colliders from the input array
    public void DisableColliderContainerArray(GameObject[] containerArray)
    {
        foreach (GameObject container in containerArray)
        {
            BoxCollider boxCollider= container.GetComponent<BoxCollider>();
            boxCollider.enabled = false;
        }
    }

    //Enables all of the colliders from the input array
    public void EnableColliderArray(BoxCollider[] colliderArray)
    {
        foreach (BoxCollider collider in colliderArray)
        {
            collider.enabled = true;
        }
    }

    //Obtains the asset used to end a path. Used for situations where no other piece fits
    public GameObject GetEndPiece()
    {
        return this.endPiece;
    }


    //Obtains the main exit collider of a room
    public Transform GetRoomMainExit(GameObject room)
    {
        if (GetRoomEntry(room) == null)
        {
            return room.transform.Find("Main Exit Connector").transform;
        }
        else
        {
            return GetRoomEntry(room).Find("Main Exit Connector").transform;
        }
    }

    //Obtains the entry collider of a room
    public Transform GetRoomEntry(GameObject room)
    {
        foreach (Transform child in room.transform)
        {
            if (child.tag == "Entry")
            {
                return child;
            }
        }
        return null;
    }

    public void AddRoomToCurrentList(GameObject roomToAdd)
    {
        this.roomsInCurrent.Add(roomToAdd);
    }

    public void AddRoomsToLevelList()
    {
        for(int i = 0; i < this.roomsInCurrent.Count(); i++)
        {
            this.roomsInLevel.Add(this.roomsInCurrent.ElementAt(i));
        }
    }

    public void DeleteRoomsForBacktrack()
    {
        //GameObject currentRoom = this.roomsInCurrent.ElementAt(this.roomsInCurrent.Count - 1);
        //this.roomsInCurrent.RemoveAt(this.roomsInCurrent.Count - 1);
        //DestroyImmediate(currentRoom);
        //GameObject previousRoom = this.roomsInCurrent.ElementAt(this.roomsInCurrent.Count - 1);
        //this.roomsInCurrent.RemoveAt(this.roomsInCurrent.Count - 1);
        //DestroyImmediate(previousRoom);
    }

    public void BacktrackRooms()
    {
        //GameObject levelObject = GameObject.Find("Level");
        //GameObject room = this.roomsInCurrent.ElementAt(this.roomsInCurrent.Count - 1);
        //string roomType = room.GetComponent<Room>().GetRoomType();
        //this.assetQueue.Insert(currentListIndex + 1, roomType);
        //DeleteRoomsForBacktrack();
        ////GameObject previousRoom = this.roomsInLevel.ElementAt(this.roomsInLevel.Count - 1);
        ////GameObject newRoom= Instantiate(roomAsset, previousRoom.transform.position, Quaternion.identity, levelObject.transform);
        //if (GetNextAssetInQueue() != null)
        //{
        //    InstantiateNextRoom(levelObject);
        //}
        //else
        //{
        //    RestartLevel();
        //}
        GameObject levelObject = GameObject.Find("Level");
        GameObject currentRoom = this.roomsInCurrent.Last();
        GameObject previousRoom = currentRoom.GetComponent<Room>().previousRoom;
     
        DestroyImmediate(currentRoom);
        this.roomsInCurrent.RemoveAt(this.roomsInCurrent.Count - 1);
        if (QueueHasMoreAsset())
        {
            InstantiateNextRoom(levelObject, previousRoom);
        }
        else
        {
            if (isEndPiece)
            {

                    //if ((PlayerPrefs.GetInt("Attempt", 1)) < this.numberOfAttempts)
                    //{
                    //    PlayerPrefs.SetInt("Attempt", PlayerPrefs.GetInt("Attempt")+1);
                    //    PlayerPrefs.Save();
                    //    SceneManager.LoadScene(SceneManager.GetActiveScene().name);
                    //}
                    //else
                    //{
                    //    PlayerPrefs.DeleteAll();
                    //}

                //    this.attemptsUsed++;
                //writeAttemptsToFile();
                SceneManager.LoadScene(SceneManager.GetActiveScene().name);


                //else
                //{
                //    PlayerPrefs.SetInt("Attempt",1);
                //    PlayerPrefs.Save();
                //    SceneManager.LoadScene(SceneManager.GetActiveScene().name);
                //}

                //RestartLevel();
            }
            else
            {
                InstatiateEndPiece(levelObject, previousRoom);
            }
        }
            
    }




    public void DestroyUsedConnectors(Transform usedEntrance, Transform usedExit)
    {
        DestroyImmediate(usedEntrance.gameObject);
        DestroyImmediate(usedExit.gameObject);
    }

    //Empties the assets associated with each terminal symbol for rooms
    public void ResetRoomAsset()
    {
        this.roomAssets = new List<RoomAsset>();
    }

    //Resets the assets associated with each terminal symbol for room content
    public void ResetContentAsset()
    {
        this.contentAssets = new List<ContentAsset>();
    }

    //Creates a new entry in roomAssets structure
    public void AddNewRoomAsset(string name)
    {
        if (name != ".")
        {
            RoomAsset newAsset = new RoomAsset();
            newAsset.name = name;
            this.roomAssets.Add(newAsset);
        }
    }

    //Creates a new entry in the contentAsset structure
    public void AddNewContentAsset(string name)
    {
        if (name != ".")
        {
            ContentAsset newAsset = new ContentAsset();
            newAsset.name = name;
            this.contentAssets.Add(newAsset);
        }
    }



    //Obtains the asset for a type of room from its name
    public GameObject GetRoomAssetFromName(string assetName)
    {
        foreach (RoomAsset roomAsset in roomAssets)
        {
            if (roomAsset.name == assetName)
            {
                return roomAsset.asset;
            }
        }
        return null;
    }


    //Obtains the asset for a type of content from its name
    public GameObject GetContentAssetFromName(string assetName)
    {
        foreach(ContentAsset contentAsset in contentAssets)
        {
            if (contentAsset.name == assetName)
            {
                return contentAsset.asset;
            }

        }
        return null;
    }

    //Creates the list of terminal symbols for rooms to associate an asset to given a grammar
    public void CreateRoomAssets(Grammar grammar)
    {
        // Generator generator = this.gameObject.GetComponent<Generator>();
         ResetRoomAsset();
         foreach(string symbol in grammar.terminalSymbols)
         {
             AddNewRoomAsset(symbol);
         }
         
    }

    //Creates the list of terminal symbols for content to associate an asset to given a grammar
    public void CreateContentAssets(Grammar grammar)
    {
        //Generator generator = this.gameObject.GetComponent<Generator>();
        ResetContentAsset();
         foreach(string symbol in grammar.terminalSymbols)
         {
             AddNewContentAsset(symbol);
         }
    }


    [Serializable]
    public struct RoomAsset
    {
        public string name;
        public GameObject asset;
    }

    [Serializable]
    public struct ContentAsset
    {
        public string name;
        public GameObject asset;
    }
}
